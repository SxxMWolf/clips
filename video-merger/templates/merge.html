{% extends "base.html" %}

{% block title %}Merge Videos - Video Clips{% endblock %}

{% block content %}
<div class="page-container">
    <header class="page-header">
        <h1>Merge Videos</h1>
        <p class="subtitle">Merge several videos into one</p>
    </header>

    <section class="merge-section">
        <div class="status-card merge-left">
            <h3>Source Video List</h3>

            <!-- Drag and Drop Upload Area -->
            <div id="drop-zone" class="drop-zone" style="margin-bottom: 20px;">
                <div class="drop-zone-content">
                    <p class="drop-zone-text">Drag and drop video files here or click to select</p>
                    <p class="drop-zone-hint">Only MP4 files are supported</p>
                    <input type="file" id="file-input" multiple accept="video/mp4" style="display: none;">
                </div>
            </div>
            <div id="upload-progress" class="upload-progress" style="display: none; margin-bottom: 20px;">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <p id="progress-text" class="progress-text">Uploading...</p>
            </div>

            <div id="raw-list" class="file-list"></div>
            <div class="status-info">
                Total <span id="raw-count">0</span>
            </div>
            <button id="clear-files-btn" class="btn btn-secondary" style="margin-top: 15px; display: none;">
                Clear
            </button>
        </div>

        <div class="form-card merge-right">
            <h3>Merge Settings</h3>
            <div class="form-group">
                <label for="keyword-input">Video Keyword (used for filename)</label>
                <input type="text" id="keyword-input" class="form-control" placeholder="e.g. AI_Future_Prediction"
                    autocomplete="off">
                <small class="form-hint">Filename will be saved with this keyword. If empty, it will be
                    auto-generated.</small>
            </div>
            <div class="form-group">
                <label>Output Aspect Ratio</label>
                <div style="display: flex; gap: 12px; margin-top: 8px; flex-wrap: wrap;">
                    <button type="button" class="aspect-ratio-btn btn btn-secondary active" data-ratio="4:5"
                        style="flex: 1; min-width: 120px;">
                        4:5 (Instagram Portrait)
                    </button>
                    <button type="button" class="aspect-ratio-btn btn btn-secondary" data-ratio="9:16"
                        style="flex: 1; min-width: 120px;">
                        9:16 (Vertical)
                    </button>
                    <button type="button" class="aspect-ratio-btn btn btn-secondary" data-ratio="16:9"
                        style="flex: 1; min-width: 120px;">
                        16:9 (Landscape)
                    </button>
                    <button type="button" class="aspect-ratio-btn btn btn-secondary" data-ratio="1:1"
                        style="flex: 1; min-width: 120px;">
                        1:1 (Square)
                    </button>
                </div>
                <small class="form-hint">Instagram supports 4:5 to 16:9 aspect ratios.</small>
            </div>
            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="add-letterbox" checked
                        style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent);">
                    <span>Add black bars (letterbox)</span>
                </label>
                <small class="form-hint">If checked, adds black bars (letterbox) to fit the aspect ratio. If unchecked,
                    video may be stretched or cropped.</small>
            </div>
            <button id="merge-btn" class="btn btn-primary btn-large">
                Start Merge
            </button>
            <p class="help-text">All source videos will be merged in filename order</p>
        </div>

    </section>

    <div class="status-card" id="result-section" style="display: none;">
        <h3>Merge Result</h3>
        <div id="merged-info"></div>
        <div id="merged-preview" class="video-preview"></div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Drag and Drop
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const uploadProgress = document.getElementById('upload-progress');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');

    // Click drop zone
    if (dropZone && fileInput) {
        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // File select
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        // Drag over
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        // Drag leave
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        // Drop
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            handleFiles(e.dataTransfer.files);
        });
    }

    // Handle files
    async function handleFiles(files) {
        const videoFiles = Array.from(files).filter(file =>
            file.type.startsWith('video/') && file.name.toLowerCase().endsWith('.mp4')
        );

        if (videoFiles.length === 0) {
            showToast('Only MP4 video files are allowed', 'error');
            return;
        }

        if (uploadProgress) {
            uploadProgress.style.display = 'block';
        }
        if (progressFill) {
            progressFill.style.width = '0%';
        }
        if (progressText) {
            progressText.textContent = 'Preparing upload...';
        }

        let uploaded = 0;
        const total = videoFiles.length;

        for (let i = 0; i < videoFiles.length; i++) {
            const file = videoFiles[i];
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload/video', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                if (result.success) {
                    uploaded++;
                    const progress = Math.round((uploaded / total) * 100);
                    if (progressFill) {
                        progressFill.style.width = progress + '%';
                    }
                    if (progressText) {
                        progressText.textContent = `Uploading... ${uploaded}/${total}`;
                    }
                } else {
                    showToast(`${file.name} Upload failed: ${result.message}`, 'error');
                }
            } catch (error) {
                showToast(`${file.name} Upload failed: ${error.message}`, 'error');
            }
        }

        if (uploaded > 0) {
            showToast(`${uploaded} files uploaded`, 'success');
            setTimeout(() => {
                if (uploadProgress) {
                    uploadProgress.style.display = 'none';
                }
                updateStatus();
            }, 1000);
        } else {
            if (uploadProgress) {
                uploadProgress.style.display = 'none';
            }
        }
    }

    // Video Order Storage (localStorage)
    let videoOrder = [];

    // Video Text Storage (localStorage)
    let videoTexts = {};

    function saveVideoOrder() {
        localStorage.setItem('video_merge_order', JSON.stringify(videoOrder));
    }

    function loadVideoOrder() {
        const saved = localStorage.getItem('video_merge_order');
        if (saved) {
            try {
                videoOrder = JSON.parse(saved);
            } catch (e) {
                videoOrder = [];
            }
        }
    }

    function saveVideoTexts() {
        // Save currently input texts
        const rawList = document.getElementById('raw-list');
        if (rawList) {
            const inputs = rawList.querySelectorAll('.video-caption-input');
            inputs.forEach(input => {
                const filename = input.dataset.filename;
                const text = input.value.trim();
                if (text) {
                    videoTexts[filename] = text;
                } else {
                    delete videoTexts[filename];
                }
            });
        }
        localStorage.setItem('video_merge_texts', JSON.stringify(videoTexts));
    }

    function loadVideoTexts() {
        const saved = localStorage.getItem('video_merge_texts');
        if (saved) {
            try {
                videoTexts = JSON.parse(saved);
            } catch (e) {
                videoTexts = {};
            }
        }
    }

    function restoreVideoTexts() {
        // Restore saved text to input fields
        const rawList = document.getElementById('raw-list');
        if (rawList) {
            const inputs = rawList.querySelectorAll('.video-caption-input');
            inputs.forEach(input => {
                const filename = input.dataset.filename;
                if (videoTexts[filename]) {
                    input.value = videoTexts[filename];
                }
            });
        }
    }

    function makeSortable() {
        const rawList = document.getElementById('raw-list');
        if (!rawList) return;

        // Sortable implementation
        let draggedElement = null;

        const items = rawList.querySelectorAll('.video-item');
        items.forEach(item => {
            item.draggable = true;
            item.style.cursor = 'move';

            item.addEventListener('dragstart', (e) => {
                draggedElement = item;
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                draggedElement = null;
            });

            item.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                const afterElement = getDragAfterElement(rawList, e.clientY);
                if (!rawList) return;
                if (afterElement == null || !afterElement || !(afterElement instanceof Node)) {
                    if (draggedElement && draggedElement instanceof Node) {
                        rawList.appendChild(draggedElement);
                    }
                } else if (afterElement instanceof Node && draggedElement instanceof Node) {
                    rawList.insertBefore(draggedElement, afterElement);
                }
            });

            item.addEventListener('drop', (e) => {
                e.preventDefault();
                updateVideoOrder();
            });
        });
    }

    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.video-item:not(.dragging)')];

        const result = draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;

            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY });

        return result.element || null;
    }

    function updateVideoOrder() {
        const rawList = document.getElementById('raw-list');
        const items = rawList.querySelectorAll('.video-item');
        videoOrder = Array.from(items).map(item => item.dataset.filename);
        saveVideoOrder();

        // Update numbers
        items.forEach((item, index) => {
            const numberSpan = item.querySelector('.video-number');
            if (numberSpan) {
                numberSpan.textContent = index + 1;
            }
        });
    }

    async function updateStatus() {
        try {
            // Updated check: if input field is focused, skip update
            const activeElement = document.activeElement;
            const isInputFocused = activeElement && activeElement.classList && activeElement.classList.contains('video-caption-input');
            if (isInputFocused || isAnyInputFocused) {
                return; // Skip completely if focused
            }

            const response = await fetch('/api/status');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const status = await response.json();

            const rawCountEl = document.getElementById('raw-count');
            if (rawCountEl) {
                rawCountEl.textContent = status.raw_count || 0;
            }
            const rawList = document.getElementById('raw-list');
            if (!rawList) {
                console.error('raw-list element not found');
                return;
            }
            if (status.raw_videos && status.raw_videos.length > 0) {
                let focusedFilename = null;
                let focusedValue = '';
                let cursorPosition = 0;

                // Save current value and cursor position of focused input
                if (isInputFocused) {
                    focusedFilename = activeElement.dataset.filename;
                    focusedValue = activeElement.value;
                    cursorPosition = activeElement.selectionStart || focusedValue.length;
                    if (focusedFilename) {
                        videoTexts[focusedFilename] = focusedValue;
                        saveVideoTexts();
                    }
                }

                // Save all input field values (even non-focused ones)
                const existingInputs = rawList.querySelectorAll('.video-caption-input');
                existingInputs.forEach(input => {
                    const filename = input.dataset.filename;
                    if (filename && filename !== focusedFilename) {
                        videoTexts[filename] = input.value;
                    }
                });

                // Use saved order if exists, otherwise server order
                loadVideoOrder();

                // Compare saved order with current file list, use only valid order
                const validOrder = videoOrder.filter(filename =>
                    status.raw_videos.includes(filename)
                );
                const newFiles = status.raw_videos.filter(filename =>
                    !videoOrder.includes(filename)
                );

                // Valid order + new files
                const orderedVideos = [...validOrder, ...newFiles];

                // Load saved texts (focused field keeps current value)
                loadVideoTexts();
                if (focusedFilename && focusedValue) {
                    videoTexts[focusedFilename] = focusedValue;
                }

                // Remove timestamp from filename for display
                rawList.innerHTML = orderedVideos.map((video, i) => {
                    const displayName = video.includes('_') ? video.split('_').slice(1).join('_') : video;
                    const videoId = `video-${i}`;
                    const savedText = videoTexts[video] || '';
                    // HTML Escape
                    const escapedText = savedText
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                    return `
                        <div class="video-item" data-filename="${video}" style="
                            padding: 12px;
                            margin-bottom: 12px;
                            background: var(--bg-secondary);
                            border: 1px solid var(--border-color);
                            border-radius: var(--radius-md);
                            transition: all 0.2s;
                            position: relative;
                        ">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                <span class="video-number" style="
                                    font-weight: 600;
                                    color: var(--accent);
                                    min-width: 24px;
                                ">${i + 1}</span>
                                <span style="flex: 1; color: var(--text-primary); text-overflow: ellipsis; overflow: hidden; white-space: nowrap;">${displayName}</span>
                                <button class="delete-video-btn" data-filename="${video}" title="Delete this video" style="
                                    background: none;
                                    border: none;
                                    color: #ff4d4d;
                                    cursor: pointer;
                                    padding: 4px 8px;
                                    border-radius: 4px;
                                    font-size: 14px;
                                    opacity: 0.6;
                                    transition: all 0.2s;
                                ">✕</button>
                                <span style="
                                    color: var(--text-muted);
                                    font-size: 12px;
                                    cursor: move;
                                ">⋮⋮</span>
                            </div>
                            <div style="margin-top: 8px;">
                                <textarea
                                    id="${videoId}"
                                    class="video-caption-input form-control"
                                    placeholder="Text to display at bottom (optional)&#10;Shift+Enter for newline"
                                    data-filename="${video}"
                                    rows="2"
                                    style="width: 100%; font-size: 13px; padding: 8px; resize: vertical; min-height: 40px;"
                                    autocomplete="off"
                                >${escapedText}</textarea>
                            </div>
                        </div>
                    `;
                }).join('');

                // Add event listeners to inputs (save text)
                const textInputs = rawList.querySelectorAll('.video-caption-input');
                textInputs.forEach(input => {
                    // Prevent Enter key default (submit), allow Shift+Enter for newline
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                        }
                        // Shift+Enter allows default behavior (newline)
                    });

                    input.addEventListener('input', (e) => {
                        const filename = e.target.dataset.filename;
                        if (filename) {
                            videoTexts[filename] = e.target.value;
                            saveVideoTexts();
                        }
                    });
                    input.addEventListener('blur', (e) => {
                        const filename = e.target.dataset.filename;
                        if (filename) {
                            videoTexts[filename] = e.target.value;
                            saveVideoTexts();
                        }
                    });
                });

                // Add event listeners to delete buttons
                const deleteBtns = rawList.querySelectorAll('.delete-video-btn');
                deleteBtns.forEach(btn => {
                    btn.addEventListener('mouseenter', () => btn.style.opacity = '1');
                    btn.addEventListener('mouseleave', () => btn.style.opacity = '0.6');
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const filename = e.target.dataset.filename;
                        if (filename) {
                            deleteVideo(filename);
                        }
                    });
                });

                // Refocus if input was focused
                if (isInputFocused && focusedFilename) {
                    const restoredInput = rawList.querySelector(`.video-caption-input[data-filename="${focusedFilename}"]`);
                    if (restoredInput) {
                        // Delay slightly to focus after DOM update
                        setTimeout(() => {
                            restoredInput.focus();
                            // Move cursor to saved position
                            const maxPosition = restoredInput.value.length;
                            const pos = Math.min(cursorPosition, maxPosition);
                            restoredInput.setSelectionRange(pos, pos);
                        }, 50);
                    }
                }

                // Update videoOrder
                videoOrder = orderedVideos;
                saveVideoOrder();


                // Enable Sortable
                setTimeout(() => makeSortable(), 100);

                // Show Clear button
                const clearFilesBtn = document.getElementById('clear-files-btn');
                if (clearFilesBtn) {
                    clearFilesBtn.style.display = 'block';
                }
            } else {
                rawList.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 20px 0;">No videos</div>';
                videoOrder = [];
                saveVideoOrder();

                // Hide Clear button
                const clearFilesBtn = document.getElementById('clear-files-btn');
                if (clearFilesBtn) {
                    clearFilesBtn.style.display = 'none';
                }
            }

            if (status.merged_exists && status.latest_merged) {
                const resultSection = document.getElementById('result-section');
                const mergedInfo = document.getElementById('merged-info');
                const mergedPreview = document.getElementById('merged-preview');

                resultSection.style.display = 'block';
                mergedInfo.innerHTML = `
                    <div style="margin-bottom: 8px;">Merge Complete</div>
                    <div style="margin-bottom: 4px;">Filename: ${status.latest_merged}</div>
                    <div style="margin-bottom: 12px;">Size: ${status.merged_size} MB</div>
                    <a href="/api/download/${status.latest_merged}" class="btn btn-primary" style="text-decoration: none; display: inline-block;">
                        Download Video
                    </a>
                `;

                // Check existing video
                const existingVideo = mergedPreview.querySelector('video');
                const existingSource = existingVideo ? existingVideo.querySelector('source') : null;
                const currentSrc = existingSource ? existingSource.getAttribute('src') : '';
                const newSrc = `/videos/${status.latest_merged}`;

                // Update only if filename changed or no video
                const currentFilename = currentSrc ? currentSrc.split('?')[0].split('/').pop() : '';
                const newFilename = status.latest_merged;

                if (currentFilename !== newFilename) {
                    // Add timestamp to prevent caching
                    const timestamp = new Date().getTime();
                    mergedPreview.innerHTML = `
                        <video controls style="width: 100%; border-radius: 10px; max-height: 400px;">
                            <source src="${newSrc}?t=${timestamp}" type="video/mp4">
                        </video>
                    `;
                }
            } else {
                document.getElementById('result-section').style.display = 'none';
            }
        } catch (error) {
            // Silently fail on server connection error (server might be restarting)
            if (error.message && error.message.includes('Failed to fetch')) {
                return;
            }
            console.error('Status update error:', error);
        }
    }

    // Aspect Ratio Selection
    let selectedAspectRatio = '4:5'; // Default (Instagram compatible)
    document.querySelectorAll('.aspect-ratio-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.aspect-ratio-btn').forEach(b => {
                b.classList.remove('btn-primary');
                b.classList.add('btn-secondary');
            });
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-primary');
            selectedAspectRatio = btn.dataset.ratio;
        });
    });
    // Select default
    document.querySelector('.aspect-ratio-btn[data-ratio="4:5"]').classList.remove('btn-secondary');
    document.querySelector('.aspect-ratio-btn[data-ratio="4:5"]').classList.add('btn-primary');

    document.getElementById('merge-btn').addEventListener('click', async () => {
        const btn = document.getElementById('merge-btn');
        const keywordInput = document.getElementById('keyword-input');
        const keyword = keywordInput.value.trim();

        // Get current order
        loadVideoOrder();
        const rawList = document.getElementById('raw-list');
        if (!rawList) {
            console.error('raw-list element not found');
            showToast('Error: Page element not found', 'error');
            return;
        }
        const items = rawList.querySelectorAll('.video-item');
        const currentOrder = Array.from(items).map(item => item.dataset.filename);

        // Get text for each video
        const currentVideoTexts = {};
        items.forEach(item => {
            const filename = item.dataset.filename;
            const input = item.querySelector('.video-caption-input');
            if (input) {
                const text = input.value.trim();
                if (text) {
                    currentVideoTexts[filename] = text;
                }
            }
        });

        // Use current order if exists, otherwise saved order
        const orderToUse = currentOrder.length > 0 ? currentOrder : videoOrder;

        btn.disabled = true;
        btn.textContent = 'Merging...';

        // Notify start
        showToast('Starting merge...', 'info');

        // Check latest file before merge
        let latestFileBefore = null;
        try {
            const statusResponse = await fetch('/api/status');
            const status = await statusResponse.json();
            latestFileBefore = status.latest_merged;
        } catch (e) {
            console.warn('Status check failed:', e);
        }

        try {
            const response = await fetch('/api/merge', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    keyword: keyword || null,
                    video_order: orderToUse.length > 0 ? orderToUse : null,
                    video_texts: Object.keys(currentVideoTexts).length > 0 ? currentVideoTexts : null,
                    aspect_ratio: selectedAspectRatio,
                    add_letterbox: document.getElementById('add-letterbox').checked
                })
            });
            const result = await response.json();

            if (result.success) {
                keywordInput.value = ''; // Reset keyword input
                // Reset order and texts after merge
                videoOrder = [];
                videoTexts = {};
                saveVideoOrder();
                saveVideoTexts();

                // Polling for completion
                let checkCount = 0;
                const maxChecks = 120; // Max 120 checks (approx 10 mins)
                const checkInterval = setInterval(async () => {
                    checkCount++;
                    try {
                        const statusResponse = await fetch('/api/status');
                        if (!statusResponse.ok) {
                            throw new Error(`HTTP error! status: ${statusResponse.status}`);
                        }
                        const status = await statusResponse.json();

                        // Check if new merged file created
                        if (status.latest_merged && status.latest_merged !== latestFileBefore) {
                            clearInterval(checkInterval);
                            showToast('Merge complete!', 'success');

                            // Try to save file using File System Access API
                            try {
                                await saveMergedVideo(status.latest_merged);
                            } catch (e) {
                                console.error('Auto save failed:', e);
                                showToast('Auto save failed, please use download button', 'warning');
                            }

                            // Update status and reload video
                            await updateStatus();
                            // Force reload video element
                            const video = document.querySelector('#merged-preview video');
                            if (video) {
                                video.load();
                            }
                            btn.disabled = false;
                            btn.textContent = 'Start Merge';
                            return;
                        }

                        if (checkCount >= maxChecks) {
                            clearInterval(checkInterval);
                            showToast('Merge may be complete or failed. Please check status.', 'warning');
                            updateStatus();
                            btn.disabled = false;
                            btn.textContent = 'Start Merge';
                        }
                    } catch (e) {
                        console.error('Status check error:', e);
                        // Silently handle server connection failure
                        if (checkCount >= maxChecks) {
                            clearInterval(checkInterval);
                            showToast('Error checking status. Please check server.', 'error');
                            btn.disabled = false;
                            btn.textContent = 'Start Merge';
                        }
                    }
                }, 5000); // Check every 5 seconds

            } else {
                showToast('Merge failed', 'error');
                btn.disabled = false;
                btn.textContent = 'Start Merge';
            }
        } catch (error) {
            showToast('Error: ' + error.message, 'error');
            btn.disabled = false;
            btn.textContent = 'Start Merge';
        }
    });

    // Individual video delete function
    async function deleteVideo(filename) {
        // Find the element and dim it while deleting
        const item = document.querySelector(`.video-item[data-filename="${filename}"]`);
        if (item) item.style.opacity = '0.5';

        try {
            const response = await fetch('/api/upload/video/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename: filename })
            });
            const result = await response.json();

            if (result.success) {
                showToast('Video deleted', 'success');
                // Remove from local order and text storage
                videoOrder = videoOrder.filter(f => f !== filename);
                delete videoTexts[filename];
                saveVideoOrder();
                saveVideoTexts();
                
                // Immediately update status
                updateStatus();
            } else {
                showToast('Delete failed: ' + result.message, 'error');
                if (item) item.style.opacity = '1';
            }
        } catch (error) {
            showToast('Error deleting video: ' + error.message, 'error');
            if (item) item.style.opacity = '1';
        }
    }

    // Clear source videos
    const clearFilesBtn = document.getElementById('clear-files-btn');
    if (clearFilesBtn) {
        clearFilesBtn.addEventListener('click', async () => {
            // if (!confirm('Are you sure you want to delete all source videos?')) {
            //    return;
            // }

            clearFilesBtn.disabled = true;
            clearFilesBtn.textContent = 'Deleting...';

            try {
                const response = await fetch('/api/upload/video/clear', { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    showToast(result.message || 'All source videos deleted', 'success');
                    updateStatus();
                } else {
                    showToast(result.message || 'Delete failed', 'error');
                }
            } catch (error) {
                showToast('Error: ' + error.message, 'error');
            } finally {
                clearFilesBtn.disabled = false;
                clearFilesBtn.textContent = 'Clear';
            }
        });
    }

    // Input focus tracking
    let isAnyInputFocused = false;
    let focusedInputElement = null;

    document.addEventListener('DOMContentLoaded', () => {
        updateStatus();

        // Track input focus (global listener)
        document.addEventListener('focusin', (e) => {
            if (e.target.classList && e.target.classList.contains('video-caption-input')) {
                isAnyInputFocused = true;
                focusedInputElement = e.target;
            }
        }, true); // capture phase

        document.addEventListener('focusout', (e) => {
            if (e.target.classList && e.target.classList.contains('video-caption-input')) {
                // Decay slightly to update focus status (might move to another input)
                setTimeout(() => {
                    const activeElement = document.activeElement;
                    if (activeElement && activeElement.classList && activeElement.classList.contains('video-caption-input')) {
                        isAnyInputFocused = true;
                        focusedInputElement = activeElement;
                    } else {
                        isAnyInputFocused = false;
                        focusedInputElement = null;
                    }
                }, 200);
            }
        }, true); // capture phase

        // Update status only if input not focused
        setInterval(() => {
            // Recheck current focus status
            const activeElement = document.activeElement;
            const currentlyFocused = activeElement && activeElement.classList && activeElement.classList.contains('video-caption-input');

            if (!currentlyFocused && !isAnyInputFocused) {
                updateStatus();
            }
        }, 5000);

    });

    // Save merged video helper
    async function saveMergedVideo(filename) {
        showToast('Preparing download...', 'info');

        try {
            // Fetch the file blob
            const response = await fetch(`/api/download/${filename}`);
            if (!response.ok) throw new Error('Download failed');
            const blob = await response.blob();

            // Check for File System Access API support
            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{
                            description: 'MP4 Video',
                            accept: { 'video/mp4': ['.mp4'] },
                        }],
                    });

                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    showToast('File saved successfully!', 'success');
                    return;
                } catch (err) {
                    // User cancelled or error
                    if (err.name !== 'AbortError') {
                        console.error('File picker error:', err);
                        // Fallback to default download if error wasn't cancellation
                        fallbackDownload(blob, filename);
                    }
                    return;
                }
            } else {
                // Fallback for browsers without API support
                fallbackDownload(blob, filename);
            }
        } catch (error) {
            console.error('Save error:', error);
            showToast('Error saving file: ' + error.message, 'error');
        }
    }

    function fallbackDownload(blob, filename) {
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        showToast('Download started', 'success');
    }
</script>
{% endblock %}